# TgFileSharingBot

A sophisticated Telegram bot designed to store, manage, and share files with users through a token-based access system. It leverages multiple channels for different functionalities and integrates with TMDB for rich media metadata and a URL shortener for token links.

## Core Concepts & How It Works

The bot operates using a multi-channel system and a token verification process for file access:

1.  **File Ingestion (Owner):**
    *   The bot owner sends video or document files directly to the bot in a private chat.
    *   The bot automatically copies these files to a dedicated **Database Channel (`DB_CHANNEL_ID`)** for storage.
    *   Alternatively, the owner can use the `/index` command to process a range of messages already existing in the `DB_CHANNEL_ID`.

2.  **File Processing & Cataloging:**
    *   Files in the `DB_CHANNEL_ID` are processed one by one from a queue.
    *   For each file, the bot:
        *   Extracts/cleans the file name.
        *   Calculates file size and duration (for videos).
        *   Attempts to fetch movie/show poster images from TMDB using the file name.
        *   Creates a new post in the **Update Channel (`UPDATE_CHANNEL_ID`)**. This post typically includes the poster (if found) or a thumbnail, file details (name, size, duration), and a crucial "Send in DM" button.

3.  **User File Access:**
    *   Users discover files by browsing the `UPDATE_CHANNEL_ID`.
    *   To get a file, a user clicks the "Send in DM" button associated with a file post. This button is a deep link (`https://telegram.dog/YOUR_BOT_USERNAME?start=FILE_ID_FROM_DB_CHANNEL`).
    *   Clicking the button opens a private chat with the bot and sends the `/start <FILE_ID>` command.

4.  **Token Verification System:**
    *   Before a user can receive a file, they must have a valid, verified token.
    *   **Requesting a Token:** If a user doesn't have a token or their token is invalid/expired, they are prompted to get one. The bot provides two buttons:
        1.  "üéüÔ∏è Get Token": This links to a **shortened URL** (generated by `shorterner.py`) which, when opened, sends a command like `/start token_UNIQUE_TOKEN_STRING` back to the bot.
        2.  "How to get verified ‚úÖ": This links to a tutorial message (e.g., explaining they might need to complete an action on the shortened link page before getting the `token_UNIQUE_TOKEN_STRING`).
    *   **Verifying a Token:** When the user sends `/start token_UNIQUE_TOKEN_STRING`, the bot checks if this string matches the one it generated for the user.
    *   **Access Granted:** If the token is verified:
        *   The token is valid for a duration defined by `TOKEN_TIMEOUT`.
        *   The user can download up to `DAILY_LIMIT` files.
        *   The requested file is then sent to the user from the `DB_CHANNEL_ID`.

5.  **Logging:**
    *   The bot uses a **Log Channel (`LOG_CHANNEL_ID`)** to post operational messages (startup, errors reported to owner) and logs certain user actions (like token verification attempts).
    *   The "How to get verified ‚úÖ" tutorial message (ID specified by `TUT_ID`) is also hosted in this `LOG_CHANNEL_ID`.

## Features

*   **Owner File Upload:** Easy file submission by sending to the bot.
*   **Automatic Indexing:** Files are processed and posted to the update channel.
*   **TMDB Integration:** Fetches posters for movies and TV shows.
*   **Token-Based Access Control:**
    *   Users need to verify a token to download files.
    *   Tokens have a configurable timeout (`TOKEN_TIMEOUT`).
    *   Daily download limit per user (`DAILY_LIMIT`).
*   **URL Shortener for Token Links:** Uses an external URL shortener for the token acquisition links.
*   **Force Subscription (Optional):** Requires users to join a specific channel before using the bot.
*   **Channel-Based Organization:**
    *   `DB_CHANNEL_ID`: Secure file storage.
    *   `UPDATE_CHANNEL_ID`: Public-facing channel for file discovery.
    *   `LOG_CHANNEL_ID`: Bot operational logs and tutorial message.
*   **User Management:** Tracks users in a MongoDB database for features like broadcasting.
*   **Broadcast Functionality:** Owner can send messages to all bot users.
*   **Log Retrieval:** Owner can fetch the bot's `log.txt` file.
*   **Restart & Update:** Owner can restart and update the bot via commands.
*   **Flask Web App:** Includes a minimal Flask app, likely for health checks on hosting platforms.

## Statistics and Monitoring

The bot includes features for monitoring its usage and ensuring system health.

*   **/stats Command (Owner Only):**
    *   Provides a summary of bot statistics.
    *   **Total Users:** The overall number of users who have ever started the bot.
    *   **New Verifications Today:** A counter for how many users have successfully verified on the current day. This number resets to zero at midnight (IST).
    *   **Files Shared Today:** A counter for the total number of files downloaded by all users on the current day. This also resets to zero at midnight (IST).
    *   **Bot Uptime:** Shows how long the bot has been running since its last restart.
    *   **Ping:** Displays the latency of the bot's response time.

*   **Daily Reset Mechanism:**
    *   The daily statistics are designed to be **restart-proof**. If the bot is offline at midnight, it will automatically run the reset the moment it comes back online, ensuring you never have incorrect or missed daily stats.
    *   This reset process is **safe** and only affects the daily statistics. It **does not** interfere with user data, token timers, or personal file limits.

*   **Token Expiration Notifications:**
    *   When a user's token expires (based on `TOKEN_TIMEOUT`), the bot will automatically detect it and send them a notification message prompting them to get a new token.
    *   A user's personal file download limit (`DAILY_LIMIT`) is tied directly to their token. It resets to zero **only** when they successfully verify with a new token, not on a daily schedule.

## Channel Configuration Explained

To use this bot, you **must** create three Telegram channels and configure the bot with their IDs:

1.  **`DB_CHANNEL_ID` (Database Channel):**
    *   **Type:** Private Channel.
    *   **Bot Role:** Administrator (with at least 'Post Messages' and 'Edit Messages' permissions).
    *   **Purpose:** This is where the bot stores all the original media files you send to it. Users do not directly interact with this channel.
    *   **Example ID:** `-100xxxxxxxxxx`

2.  **`UPDATE_CHANNEL_ID` (Updates/Public Channel):**
    *   **Type:** Public or Private Channel (Public recommended for easier discovery).
    *   **Bot Role:** Administrator (with at least 'Post Messages' permissions).
    *   **Purpose:** This is where the bot posts formatted messages about the available files (e.g., movie poster, file name, size, and a "Send in DM" button). Users will browse this channel to find files.
    *   **Example ID:** `-100yyyyyyyyyy` (if private) or `@yourchannelusername` (if public, but the bot needs the numerical ID for sending).

3.  **`LOG_CHANNEL_ID` (Log Channel):**
    *   **Type:** Private Channel.
    *   **Bot Role:** Administrator (with at least 'Post Messages' and 'Read Message History' permissions, as it needs to copy the `TUT_ID` message).
    *   **Purpose:** The bot sends operational logs, status updates, and some error reports here. It also hosts the tutorial message for token verification (its Message ID is set in `TUT_ID`).
    *   **Example ID:** `-100zzzzzzzzzz`

**Important:**
*   The bot *must* be an administrator in all these channels with the necessary permissions.
*   Channel IDs for private channels are negative numbers (e.g., `-1001234567890`). You can get these IDs by forwarding a message from the channel to a bot like `@JsonDumpBot` or `@MissRose_bot` (use `/id` in the channel where Rose is an admin).

## Environment Variables

Create a `config.env` file in the root directory or set these environment variables directly in your hosting environment.

| Variable              | Description                                                                                                | Example (from `config_sample.env`) |
| --------------------- | ---------------------------------------------------------------------------------------------------------- | ---------------------------------- |
| `API_ID`              | Your Telegram API ID from my.telegram.org.                                                                 | `123456`                           |
| `API_HASH`            | Your Telegram API Hash from my.telegram.org.                                                               | `your_api_hash`                    |
| `BOT_TOKEN`           | The token for your Telegram bot from BotFather.                                                            | `your_bot_token`                   |
| `OWNER_ID`            | Your Telegram User ID. The bot owner.                                                                      | `your_user_id`                     |
| `DB_CHANNEL_ID`       | Numerical ID of the private channel where files are stored.                                                | `-100xxxxxxxxxx`                   |
| `LOG_CHANNEL_ID`      | Numerical ID of the private channel for bot logs and the token tutorial message.                           | `-100yyyyyyyyyy`                   |
| `UPDATE_CHANNEL_ID`   | Numerical ID of the channel where formatted file posts are made.                                           | `-100zzzzzzzzzz`                   |
| `TUT_ID`              | Message ID of the tutorial/instructions message (located in `LOG_CHANNEL_ID`) for token verification.      | `3`                                |
| `MONGO_URI`           | MongoDB connection string for user database.                                                               | `mongodb+srv://...`                |
| `TMDB_API_KEY`        | API key for The Movie Database (TMDB) to fetch movie/show posters. Optional, but recommended.              | `your_tmdb_api_key`                |
| `URLSHORTX_API_TOKEN` | API token for your chosen URL shortener service (compatible with urlshortx.com API format).                | `your_shortener_api_token`         |
| `SHORTERNER_URL`      | Base domain of your URL shortener service (e.g., `urlshortx.com` or your self-hosted instance).            | `urlshortx.com`                    |
| `TOKEN_TIMEOUT`       | Duration in seconds for how long a verified token remains valid. (8 hours = 28800)                         | `28800`                            |
| `DAILY_LIMIT`         | Maximum number of files a user can download per token validity period.                                     | `10`                               |
| `FORCE_SUB_CHANNEL`   | (Optional) Channel ID or Link that users must join to use the bot.                                         | `-100xxxx` or `https://t.me/xxxx`  |
| `AUTO_DELETE_TIME`    | (Optional) Time in seconds to auto-delete sent files. Defaults to 60s.                                     | `60`                               |
| `CONFIG_FILE_URL`     | (Optional) A direct URL to a `config.env` file. If set, the bot will try to download it on startup/update. |                                    |
| `UPSTREAM_REPO`       | (Optional) Git repository URL for bot updates (used by `update.py`). Defaults to original repo.            |                                    |
| `UPSTREAM_BRANCH`     | (Optional) Git repository branch for bot updates. Defaults to `main`.                                      |                                    |

## Deployment

### Prerequisites

*   Python 3.10+
*   Git
*   MongoDB instance

### Manual Setup

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/your-username/TgFileSharingBot.git
    cd TgFileSharingBot-main
    ```

2.  **Create `config.env`:**
    Copy `config_sample.env` to `config.env` and fill in your details:
    ```bash
    cp config_sample.env config.env
    nano config.env # Or your preferred editor
    ```

3.  **Install dependencies:**
    ```bash
    pip3 install -r requirements.txt
    ```

4.  **Set up Channels:**
    *   Create the three required Telegram channels (`DB_CHANNEL_ID`, `UPDATE_CHANNEL_ID`, `LOG_CHANNEL_ID`).
    *   Make your bot an admin in all three channels with necessary permissions.
    *   Add the `TUT_ID` message in your `LOG_CHANNEL_ID` (e.g., a message explaining how to click the link from the shortener and what to expect). Get its message ID and put it in `config.env`.

5.  **Run the bot:**
    The `CMD` in the Dockerfile is `["sh", "start.sh"]`. If a `start.sh` is not provided in your version, you'd typically run `bot.py`. Assuming `start.sh` contains `python3 bot.py`:
    ```bash
    sh start.sh
    # OR if start.sh is missing/simple:
    # python3 bot.py
    ```
    (Note: The provided `start.sh` is not in the file list, but the Dockerfile calls it. If it's simple, it might just be `python3 bot.py & python3 app.py`. For a production setup, `gunicorn app:app` would be better for the Flask part if it were more complex.)

### Docker Setup

1.  **Prepare `config.env`:** Ensure your `config.env` file is in the `TgFileSharingBot-main` directory and correctly filled.
2.  **Build the Docker image:**
    ```bash
    docker build -t tgfilesharingbot .
    ```
3.  **Run the Docker container:**
    ```bash
    docker run -d --env-file ./config.env --name filebot tgfilesharingbot
    ```
    (Note: The Dockerfile copies `config.env` if `CONFIG_FILE_URL` is not used effectively. It's generally better to pass env vars directly or use `--env-file` if your Dockerfile doesn't handle `config.env` robustly via `CONFIG_FILE_URL`.)
    The current Dockerfile *copies* `requirements.txt` and then `COPY . .`, so if `config.env` is present at build time, it *could* be copied in, but it's better practice to manage secrets outside the image. The `CONFIG_FILE_URL` mechanism in `config.py` is an attempt to fetch it at runtime.

## Key Commands

### Owner Commands (Private Chat with Bot)

*   **(Send File):** Send any video or document file directly to the bot. It will be copied to `DB_CHANNEL_ID` and then processed for `UPDATE_CHANNEL_ID`.
*   `/index`: Prompts for a start and end message ID from `DB_CHANNEL_ID` to batch process/re-process files.
*   `/cancel`: Cancels an ongoing `/index` operation.
*   `/broadcast` (as a reply to a message): Broadcasts the replied message to all users in the database.
*   `/log`: Sends the `log.txt` file to the owner.
*   `/restart`: Restarts the bot. Pulls updates from `UPSTREAM_REPO` if configured, then restarts the Python process.

### BotFather Copyable Commands

```
start - Start the bot
verify - Manually verify a user (Owner Only)
settings - Open bot settings (Owner Only)
unban - Unban a user (Owner Only)
broadcast - Broadcast a message (Owner Only)
stats - Show bot statistics (Owner Only)
log - Get log file (Owner Only)
delete - Delete messages from update channel (Owner Only)
index - Index files from DB channel (Owner Only)
restart - Restart the bot (Owner Only)
me - Show your profile (User)
status - Show your profile (User)
```

### User Commands (Private Chat with Bot)

*   `/start`: Shows a welcome message.
*   `/start <file_id>`: (Usually triggered by the "Send in DM" button from `UPDATE_CHANNEL_ID`) Initiates the file download process, including token verification.
*   `/start token`: (Usually triggered by a button when access is denied) Sends the user a message (copied from `LOG_CHANNEL_ID` via `TUT_ID`) explaining how to get a token, along with a "üéüÔ∏è Get Token" (shortened link) and "How to get verified ‚úÖ" button.
*   `/start token_<unique_token_string>`: (Usually triggered by visiting the shortened token link) Attempts to verify the `unique_token_string`.
*   `/me` or `/status`: Shows your current verification status, token expiry time, and daily file limit usage.

## Disclaimer

This bot offers powerful file sharing capabilities. Ensure you comply with Telegram's Terms of Service and respect copyright laws. The developers are not responsible for how this bot is used.
